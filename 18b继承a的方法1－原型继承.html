<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>继承方法1 --原型链继承 </title>
		<script type="text/javascript" src="jquery-3.1.1.min.js"></script>
	</head>
	<body>
			<!-- 继承方法1 --原型链继承 -->
		<script type="text/javascript">
			function Animal(name){
				this.name = name;
				this.sleep = function(){
					console.log(this.name + '正在睡觉'); // cat正在睡觉
				}
			}
			Animal.prototype.eat = function(food){
				console.log(this.name+'正在吃：'+food); //cat正在吃：fish
			}
			/*1、原型链继承
                              核心： 将父类的实例作为子类的原型*/
			function Cat(){
				
			}
			Cat.prototype = new Animal();
			Cat.prototype.name = 'cat';
			var cat = new Cat();
			console.log(cat.name); //cat
			console.log(cat.sleep()); // undefined
			console.log(cat.eat('fish')); //undefined
			console.log(cat instanceof Animal); //true
			console.log(cat instanceof Cat); //true
			
		</script>
		
		<!--特点：
		非常纯粹的继承关系，实例是子类的实例，也是父类的实例
		父类新增原型方法/原型属性，子类都能访问到
		简单，易于实现
		
		缺点：
		要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
		无法实现多继承
		来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）
		创建子类实例时，无法向父类构造函数传参-->
	</body>
</html>
